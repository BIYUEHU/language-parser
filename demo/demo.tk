import { Show, Eq } from "prelude"
import as std from "stdlib"

// Data type definitions
type Bool = True | False
<<<<<<< HEAD
type Nat = Z | S(Nat)
type Nat2 =
 | Z2
 | S2 => Nat2
type Pair = <A, B> MkPair(A, B)
type Maybe = <A> Just(A) | Nothing
type Result = <A, E> Ok(A) | Err(E)
export abstract type Option = <A> Some(A) | None
export type List = <A> Nil | Cons(A, List(A))
type Vector = <L: Nat, A: Kind>
 | VNil => Vector(Z, A)
 | VCons => A => Vector(L, A) => Vector(S(L),A)

// Type aliases
export let String = List(Char)
let Array = List
let Function: Kind -> Kind -> Kind = (A, B) => A -> B
let ShowFn = (A: Kind) => Function(A, String)
let IntToStringFn = Int -> String

// Common List functions with correct type declarations
export let map: <A, B> (A -> B) -> List(A) -> List(B) =
    | Nil => Nil
    | Cons(x, xs) => Cons(f(x), map(f, xs))

export let foldr: <A, B> (A -> B -> B) -> B -> List(A) -> B =
    | Nil => acc => acc
    | Cons(x, xs) => acc => f(x)(foldr(f)(acc)(xs))

export let foldl: <A, B> (B -> A -> B) -> B -> List(A) -> B =
    | Nil => acc => acc
    | Cons(x, xs) => acc => foldl(f)(f(acc)(x))(xs)

let append: <A> List(A) -> List(A) -> List(A) =
    | Nil => ys => ys
    | Cons(x, xs) => ys => Cons(x, append(xs)(ys))

let filter: <A> (A -> Bool) -> List(A) -> List(A) =
    | Nil => Nil
    | Cons(x, xs) => match p(x) then
        | True => Cons(x, filter(p)(xs))
        | False => filter(p)(xs)

let reverse: <A> List(A) -> List(A) =
    | Nil => Nil
    | Cons(x, xs) => append(reverse(xs), Cons(x, Nil))

let compose: = <A, B, C>
    (f: B -> C, f: A -> B, x: A -C) => f(g(x))

let fst: Pair<A, B> -> A =
    | MkPair(x, _) => x

let snd: Pair<A, B> -> B =
    | MkPair(_, y) => y

// Let-in expression
let factorial: Nat -> Nat = n =>
    let helper: Nat -> Nat -> Nat =
        | Zero => acc => acc
        | Succ(n) => acc => helper(n, mul(Succ(n), acc))
    in helper(n, Succ(Zero))

// Match expression
let isZero: Nat -> Bool = n => match n then
    | Zero => True
    | Succ(_) => False

// Curried function
let add: Nat -> Nat -> Nat =
    | Zero => n => n
    | Succ(m) if m > 5 => n => Succ(add(m, n))
    | Succ(m) => m

let addFive = add(5)
=======
type Option = <T> Some(T) | None
type List = <T> Cons(T, List<T>) | Nil
type Result = <E, T> Ok(T) | Err(E)
type MyType = MkMyType

// 类型别名
let String: Kind = [Char]
let ToStringF: Kind -> Kind = t => t -> String

// 函数定义
let add: Int -> Int -> Int = x => y => x + y
let add: Int -> Int -> Int = (x, y) => x + y

// 复杂的类型定义
type State: Kind -> Kind -> Kind = <S, A> State(S -> (A, S))

// 模式匹配表达式
let map: List(A) -> (A -> B) -> List(B) =
    (xs, f) => match xs then
        | Nil => Nil
        | Cons(x, xs) => Cons(f(x), map(xs, f))


// 函数调用
map(["a", "b"], x => x + "!")

// 手动指定带泛型的函数
map<Int, String>([1, 2, 3], show)

// if 表达式
let max: Int -> Int -> Int = (x, y) =>
    if x > y then x else y

// 块表达式和let绑定
let compute = {
    let x = 10
    let y = 20
    x + y
}

// 高阶函数
let compose: (B -> C) -> (A -> B) -> (A -> C) =
    (f, g) => x => f(g(x))

// 递归函数
let fibonacci: Int -> Int =
    n => match n then
        | 1 => 1
        | 2 => 1
        | n => fibonacci(n - 1) + fibonacci(n - 2)
    

// 函数模式匹配语法糖
let fibonacii2: Int -> Int =
 | 1 => 1
 | 2 => 1
 | n => fibonacci2(n - 1) + fibonacci2(n - 2)
>>>>>>> c3c6015ab524121fe90f20cec69bb58c6ea14c34
